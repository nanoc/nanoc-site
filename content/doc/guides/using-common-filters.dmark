---
title: "Using common filters"
---

#p This guide gives an overview of typical approaches for using common filters.

#section %h{Using Sass}
  #p %ref[url=http://sass-lang.com/]{Sass} is a CSS extension language that supports variables, mixins, partials, and more. To use Sass with Nanoc, create a rule that matches %glob{/**/*.sass}, calls the %code{:sass} filter, and writes out a %filename{.css} file:

  #listing[lang=ruby]
    compile '/**/*.sass' do
      filter :sass
      write item.identifier.without_ext + '.css'
    end

  #p If you prefer using the SCSS syntax for Sass, rather than the default Sass syntax, pass %code{syntax: :scss} to the %code{:sass} filter, and match on %glob{/**/*.scss} rather than %glob{/**/*.sass}:

  #listing[lang=ruby]
    compile '/**/*.scss' do
      filter :sass, syntax: :scss
      write item.identifier.without_ext + '.css'
    end

  #p For more information, see the %ref[item=/doc/reference/filters.*,frag=sass]{%code{:sass} filter reference}.

#section %h{Using advanced Sass features}
  #p Beside the basic rendering of %ref[url=http://sass-lang.com/]{Sass} stylesheet to CSS, Nanoc can also help you with partials and source maps.

  #listing[lang=ruby]
    [:default, :sourcemap].each do |rep|      # define 2 reps for stylesheets
      compile '/css/**/_*', :rep => rep do    # ignore partials
      end
    end

    [:default, :sourcemap].each do |rep|
      compile '/css/**/*.{sass,scss%}', :rep => rep do
        next if @item.raw_content.empty?      # ignore empty files
        syntax = @item[:extension].to_sym
        path = @item.identifier.without_ext + '.css'
        options = { syntax: syntax, style: compact, sourcemap_path: path + '.map' %}
        case rep
        when :default
          filter :sass, options
          write path
        when :sourcemap
          filter :sass_sourcemap, options
          write path + '.map'
        end
      end
    end

  #p With the rules defined above, you will be able to import Sass partials by identifiers.

  #listing[lang=sass]
    @import "/css/**/_bootstrap*.*";

  #p Finally, Nanoc defines a %code{nanoc()} Sass function that lets you evaluate Ruby code from Sass within the compilation context.

  #listing[lang=sass]
    .title {
      content: nanoc('@config[:title][:text]')
      color: nanoc('@config[:title][:color]', $unquote: true)
    %}

  #p Which assumes your %filename{nanoc.yaml} configuration contains:

  #listing[lang=yaml]
    title:
      text: Hello World!
      color: pink

  #p For more information, see the %ref[item=/doc/reference/filters.*,frag=sass]{%code{:sass} filter reference}.

#section %h{Using kramdown}
  #p %ref[url=http://kramdown.gettalong.org/]{kramdown} is a fast and featureful Markdown processor. To use it with Nanoc, create a rule that matches %glob{/**/*.md} and calls the %code{:kramdown} filter:

  #listing[lang=ruby]
    compile '/**/*.md' do
      filter :kramdown
      layout '/default.*'
      write item.identifier.without_ext + '.html'
    end

  #p The %code{:kramdown} filter can take options. For example, pass %code{auto_ids: false} to disable automatic header ID generation:

  #listing[lang=ruby]
    compile '/**/*.md' do
      filter :kramdown, auto_ids: false
      layout '/default.*'
      write item.identifier.without_ext + '.html'
    end

  #p For more information, see the %ref[item=/doc/reference/filters.*,frag=kramdown]{%code{:kramdown} filter reference}.
